\documentclass{beamer}

%\usetheme{Madrid}
\setbeameroption{show notes}
\setbeamertemplate{navigation symbols}{}

\usepackage{listings}
\lstset{language=[ISO]C++,
        basicstyle=\ttfamily\scriptsize,
        keywordstyle=\color{blue},
        stringstyle=\color{red},
        commentstyle=\color{green},
        frame=single,
        }
        
\usepackage{lmodern}
\usepackage{color}

\title{Advanced Programming Techniques}
\author{David Schneider}


\AtBeginLecture{%
  \section{\insertlecture}\frame{\Large\insertlecture}%
}

\begin{document}

\frame{\titlepage}

\lecture{Introduction}

\subsection{Object-oriented programming}

\begin{frame}{Pradigma}
OOP is a programming pradigma

Objects contain
\begin{itemize}
\item data (ak. attribute)
\item code (ak. methods)
\end{itemize}

\end{frame}

\begin{frame}{OOP vs. Procedural}

\begin{block}{Procedural}
data tends to be highly decoupled from the functions that operate on it
\end{block}

\begin{block}{Object-oriented}
data tends to carry with it a collection of functions
\end{block}

\note{http://stackoverflow.com/a/552474/6632389}

\end{frame}

\subsection{Object-oriented concepts}

\begin{frame}{Classes and objects}

\begin{block}{Class}
The blueprint for an object. Defines how a object should be created.
\end{block}

\begin{block}{Object}
An instance of a class. Gets created during runtime.
\end{block}

\end{frame}

\begin{frame}{Information hidding}
Encapsulate data and hide the internal structure from caller. This allows
changing the internal details without affecting 
\end{frame}

\begin{frame}{Inheritance}
Exentend or overwrite functionality of another class.
\end{frame}

\begin{frame}{Interface}
Define a method without implementing it as an interface to be used by other
classes.
\end{frame}

\begin{frame}{Polymorphism}
\framesubtitle{aka Subtyping}
Define a implementation for a specialized type.
\end{frame}

\subsection{C++}
\begin{frame}{C++ - Overview}
\begin{itemize}
  \item compiled language
  \item general-purpose programming language
  \item Multi-pradigma
  \begin{itemize}
    \item procedural
    \item functional
    \item object-oriented
    \item generic
  \end{itemize}
  \item statically typed
  \item allows low-level memory manipulation
  \item designed for large, resource constrained systems 
\end{itemize}
\end{frame}


\begin{frame}{C++ - Standardization}
\itemize{}
\item[1979] C with Classes first implemented 
\item[1998] C++98 (ISO/IEC 14882:1998) 
\item[2003] C++03 (ISO/IEC 14882:2003)
\item[2011] C++11 (ISO/IEC 14882:2011)
\note[item]{C++11 major extension over C++03} 
\item[2014] C++14 (ISO/IEC 14882:2014)
\note[item]{C++14 small extension over C++11, featuring mainly bug fixes
 and small improvements}
\item[2017] C++17 (also called C++1z)
\end{frame}

\begin{frame}{Emedded Systems}
\begin{itemize}
  \item Embedded C++ (still in use?)
\end{itemize}
\end{frame}

\lecture{Buildsystem}
\subsection{Tools}
\begin{frame}{Tools}
\begin{description}
  \item[Code:Blocks] \url{http://www.codeblocks.org/}
  \note[item]{Code:Blocks: IDE, Contains GCC compiler}
  \item[Git for Windows] \url{https://git-for-windows.github.io/}
  \note[item]{Git for Windows: Git CLI (git.exe) used as back-end for
  TortoiseGit}
  \item[TortoiseGit] \url{https://tortoisegit.org/}
  \item[CMake] \url{https://cmake.org/}  
\end{description}

\begin{note}
  
\end{note}
 
\end{frame}

\lecture{OO-Basics}

\begin{frame}
Design is all about changable code.
Code is written once, but read many times.
\end{frame}

\subsection{Features}

\begin{frame}
accessibility
\end{frame}

\begin{frame}{Encapsulation}
abstraction
information hidding
hide internal details, which allows changing this details
\end{frame}

\begin{frame}{Inheritance}
Base class
Abstract class
\end{frame}

\begin{frame}{Composition and delegation}
TODO
\end{frame}

\begin{frame}{Polymorphism}
subtyping
\end{frame}

\begin{frame}{Open recursion}
Virtual methods

\lstinputlisting[caption=Open recursion]{lst/open_recursion.cpp}


\end{frame}


\subsection{Pattern}


\frame{GRASP}

\subsection{SOLID}

\begin{frame}{S.O.L.I.D - Principals}
Defined by Robert C. Martin (Oncle Bob)


\begin{description}
\item [S] Single-responsiblity principle
\item [O] Open-closed principle
\item [L] Liskov substitution principle
\item [I] Interface segregation principle
\item [D] Dependency Inversion Principle
\end{description}
\end{frame}

\begin{frame}{Single-responsiblity principle}
a class should have only a single responsibility (i.e. only one potential change
in the software's specification should be able to affect the specification of the class)
\end{frame}

\begin{frame}{Open-closed principle}
''A module should be open for extension but closed for modification''
\end{frame}

\begin{frame}{Liskov substitution principle}
''objects in a program should be replaceable with instances of their subtypes
without altering the correctness of that program.''
\end{frame}

\begin{frame}{Interface segregation principle}
\end{frame}

\begin{frame}{Dependency Inversion Principle}
\end{frame}

\subsection{Clean Code}

\lecture{Object Oriented Design - Pattern}

\begin{frame}{Pattern}
\begin{itemize}
  \item singelton
  \item factory
  \item command
  \item observer
  \item strategy
  \item visitor
  \item null object
  \item adapter
  \item proxy
  \item fly-weight
\end{itemize}
\end{frame}

\lecture{C++}

\begin{frame}{Source}
C++ Language Tutorial
Source: \url{http://www.cplusplus.com/doc/tutorial/}
\note{reference on cplusplus.com contains some errors,
http://stackoverflow.com/questions/6520052/whats-wrong-with-cplusplus-com}
\end{frame}

\part{Basics of C++}
\subsection{Structure of a program}

\subsection{Variables and types}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Identifiers}
\begin{itemize}
  \item case-sensitive
  \item sequence of one or more letters, digits, or underscore
  \item always begin with a letter
  \item begin with underscore allowd, but used for special cases
  \item many reserved keywords, which can't be used as identifiers 
\end{itemize}
\begin{lstlisting}[caption=Identifiers Examples]
aNumber
my1st_variable
SomeMoreIdentifier
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Fundamental data types}
\begin{itemize}
  \item Character types
  \item Numerical integer types
  \item Floating-point types
  \item Boolean type
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Fundamental data types}
\includegraphics[scale=0.48]{img/FundamentalTypes.png}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Declaration of variables}
\begin{itemize}
  \item Strongly typed
  \item Every variable to be declared before first use
\end{itemize}
\begin{lstlisting}[caption=Variable declaration]
int aNumber;
float aFloatingPointerNumber;
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Initialization of variables}
\begin{definition}{Initialization}
   Set the value of variable during declaration. 
\end{definition}
\begin{lstlisting}[caption=Variable initialization]
int aNumber = 5;
float aFloatingPointerNumber(6);
\end{lstlisting}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Type deduction: auto and decltype}
Automatic type determination with keyword `auto`.

Usefull for cases where the explicitly type is not so importent or the type is
so complex (ex. with templates) that it's hard the define the type correct.

\lstinputlisting[caption=Auto Type]{lst/AutoType.cpp}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Introduction to strings}
Example for compound types: std::string

\lstinputlisting[caption=String Example]{lst/SimpleString.cpp}

\end{frame}


\subsection{Constants}
\subsection{Operators}
\subsection{Basic Input/Output}

\part{Program structure}
\subsection{Control Structures}
\subsection{Functions}
\subsection{Overloads and templates}
\subsection{Name visibility}

\part{Compound data types}
\subsection{Arrays}
\subsection{Character sequences}
\subsection{Pointers}
\subsection{Dynamic Memory}
\subsection{Data structures}
\subsection{Other data types}

\part{Classes}
\subsection{Classes}
\subsection{Special members}
\subsection{Friendship and inheritance}
\subsection{Polymorphism}

\part{Other language features}
\subsection{Type conversions}
\subsection{Exceptions}
\subsection{Preprocessor directives}

\lecture{C++ and C}

\lecture{Standards}

\lecture{Clean Code}

\lecture{Coding Standards}

\subsection{MISRA}

\lecture{Testing}
\part{MyPart}
\subsection{Test-pyramid}
\subsection{Unittest (SIL-test)}
\subsection{Design for testability}
\subsubsection{test}

\end{document}
