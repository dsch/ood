\documentclass{beamer}
\usetheme{Madrid}
\setbeameroption{show notes}

\usepackage{listings}
\lstset{language=[ISO]C++,
        keywordstyle=\color{blue},
        stringstyle=\color{red},
        commentstyle=\color{green},
        frame=single,
        }
        
\usepackage{lmodern}
\usepackage{color}

\title{Object Oriented Design}
\author{David Schneider}

\AtBeginLecture{\section{\insertlecture}\frame{\Large\insertlecture}}

\begin{document}

\frame{\titlepage}

\lecture{Introduction}

\section{Object-oriented programming}

\begin{frame}{Pradigma}
OOP is a programming pradigma

Objects contain
\begin{itemize}
\item data (ak. attribute)
\item code (ak. methods)
\end{itemize}

\end{frame}

\begin{frame}{OOP vs. Procedural}

\begin{block}{Procedural}
data tends to be highly decoupled from the functions that operate on it
\end{block}

\begin{block}{Object-oriented}
data tends to carry with it a collection of functions
\end{block}

\note{http://stackoverflow.com/a/552474/6632389}

\end{frame}

\section{Object-oriented concepts}

\begin{frame}{Classes and objects}

\begin{block}{Class}
The blueprint for an object. Defines how a object should be created.
\end{block}

\begin{block}{Object}
An instance of a class. Gets created during runtime.
\end{block}

\end{frame}

\begin{frame}{Information hidding}
Encapsulate data and hide the internal structure from caller. This allows
changing the internal details without affecting 
\end{frame}

\begin{frame}{Inheritance}
Exentend or overwrite functionality of another class.
\end{frame}

\begin{frame}{Interface}
Define a method without implementing it as an interface to be used by other
classes.
\end{frame}

\begin{frame}{Polymorphism}
\framesubtitle{aka Subtyping}
Define a implementation for a specialied type.
\end{frame}

\section{C++}
\subsection{Overview}
\begin{frame}{C++ - Overview}
\begin{itemize}
  \item compiled language
  \item general-purpose programming language
  \item Multi-pradigma
  \begin{itemize}
    \item procedural
    \item functional
    \item object-oriented
    \item generic
  \end{itemize}
  \item statically typed
  \item allows low-level memory manipulation
  \item designed for large, resource constrained systems 
\end{itemize}
\end{frame}

\subsection{Standardization}
\begin{frame}{C++ - Standardization}
\itemize{}
\item[1979] C with Classes first implemented 
\item[1998] C++98 (ISO/IEC 14882:1998) 
\item[2003] C++03 (ISO/IEC 14882:2003)
\item[2011] C++11 (ISO/IEC 14882:2011)
\note[item]{C++11 major extension over C++03} 
\item[2014] C++14 (ISO/IEC 14882:2014)
\note[item]{C++14 small extension over C++11, featuring mainly bug fixes
 and small improvements}
\item[2017] C++17 (also called C++1z)
\end{frame}

\begin{frame}{Emedded Systems}
\begin{itemize}
  \item Embedded C++ (still in use?)
\end{itemize}
\end{frame}

\lecture{Buildsystem}

\lecture{OO-Basics}


\begin{frame}
Design is all about changable code.
Code is written once, but read many times.
\end{frame}

\section{Features}

\begin{frame}
\subsection{Objects and classes}
accessibility
\end{frame}

\subsection{Encapsulation}
\begin{frame}{Encapsulation}
abstraction
information hidding
hide internal details, which allows changing this details
\end{frame}

\subsection{Inheritance}
\begin{frame}{Inheritance}
Base class
Abstract class
\end{frame}

\subsection{Composition and delegation}
\subsection{Polymorphism}
\begin{frame}{Polymorphism}
subtyping
\end{frame}

\subsection{Open recursion}
\begin{frame}{Open recursion}[fragil]
Virtual methods

\lstinputlisting[caption=Open recursion]{lst/open_recursion.cpp}


\end{frame}


\section{Pattern}


\subsection{GRASP}

\subsection{SOLID}

\begin{frame}{S.O.L.I.D - Principals}
From by Robert C. Martin (Oncle Bob)


\begin{description}
\item [S] Single-responsiblity principle
\item [O] Open-closed principle
\item [L] Liskov substitution principle
\item [I] Interface segregation principle
\item [D] Dependency Inversion Principle
\end{description}
\end{frame}

\begin{frame}{Single-responsiblity principle}
a class should have only a single responsibility (i.e. only one potential change
in the software's specification should be able to affect the specification of the class)
\end{frame}

\begin{frame}{Open-closed principle}
''A module should be open for extension but closed for modification''
\end{frame}

\begin{frame}{Liskov substitution principle}
''objects in a program should be replaceable with instances of their subtypes
without altering the correctness of that program.''
\end{frame}

\begin{frame}{Interface segregation principle}
\end{frame}

\begin{frame}{Dependency Inversion Principle}
\end{frame}

\section{Clean Code}

\lecture{Object Oriented Design - Pattern}

\lecture{C++ Features}

\lecture{C++ and C}

\lecture{Standards}

\lecture{Clean Code}

\lecture{Testing}

\begin{frame}
\begin{itemize}
  \item Test-pyramid
  \item Unittest (SIL-test)
  \item Design for testability
\end{itemize}

\end{frame}

\end{document}
